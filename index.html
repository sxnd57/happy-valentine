<!doctype html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Valentine Cinematic - Falling Letters</title>

    <link
      href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Segoe+UI:wght@300;400;700&display=swap"
      rel="stylesheet"
    />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/TextPlugin.min.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Dancing Script", cursive;
        user-select: none;
      }
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }

      /* --- GREETING OVERLAY (M√†n h√¨nh ch·ªù ban ƒë·∫ßu) --- */
      #greeting-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 200;
        pointer-events: none;
      }
      #greeting-overlay h5 {
        color: #ff0055;
        font-size: 2rem;
        margin: 0;
        text-shadow: 0 0 30px rgba(255, 0, 85, 0.8);
        text-align: center;
        opacity: 0;
      }
      #greeting-overlay p {
        color: #fff;
        font-size: 1rem;
        margin-top: 20px;
        font-weight: 300;
        letter-spacing: 2px;
        max-width: 80%;
        text-align: center;
        line-height: 1.6;
        opacity: 0;
      }

      /* --- MAIN MESSAGE (L·ªùi ch√∫c sau khi g√¥m t·ª•) --- */
      #main-message {
        position: fixed;
        top: 30%; /* Canh gi·ªØa m√†n h√¨nh */
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%; /* Gi·ªõi h·∫°n chi·ªÅu r·ªông ƒë·ªÉ ƒëo·∫°n vƒÉn kh√¥ng b·ªã tr√†n */
        text-align: center;
        color: #fff0f5;
        font-family: "Dancing Script", cursive;
        /* Gi·∫£m k√≠ch th∆∞·ªõc font ƒë·ªÉ ph√π h·ª£p v·ªõi ƒëo·∫°n vƒÉn d√†i */
        font-size: 1.5rem;
        line-height: 1.6; /* TƒÉng kho·∫£ng c√°ch d√≤ng cho d·ªÖ ƒë·ªçc */
        z-index: 150;
        pointer-events: none;
        text-shadow:
          0 0 10px rgba(255, 20, 147, 0.8),
          0 0 20px rgba(255, 20, 147, 0.5);
        opacity: 0; /* ·∫®n m·∫∑c ƒë·ªãnh */
      }

      /* Responsive cho mobile */
      @media (max-width: 768px) {
        #main-message {
          font-size: 1.5rem;
          width: 90%;
        }
      }

      /* --- FALLING LETTERS (TH∆Ø R∆†I) --- */
      #letters-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 100;
        pointer-events: none; /* Click xuy√™n qua v√πng tr·ªëng */
        overflow: hidden;
      }

      .falling-item {
        position: absolute;
        font-size: 2.5rem;
        cursor: pointer;
        pointer-events: auto; /* ƒê·ªÉ b·∫Øt s·ª± ki·ªán click */
        filter: drop-shadow(0 0 10px rgba(255, 192, 203, 0.5));
        transition: transform 0.1s;
        will-change: transform;
        top: -100px;
        left: 0;
      }

      .falling-item:hover {
        transform: scale(1.3);
        filter: drop-shadow(0 0 15px #fff);
        z-index: 150;
      }

      /* --- MODAL --- */
      #card-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 300;
        display: none;
        justify-content: center;
        align-items: center;
        opacity: 0;
        backdrop-filter: blur(5px);
      }
      .modal-content {
        background: #fff0f5;
        width: 350px;
        min-height: 250px;
        padding: 30px;
        border-radius: 15px;
        position: relative;
        box-shadow: 0 0 50px rgba(255, 105, 180, 0.6);
        text-align: center;
        transform: scale(0.5);
        background-image: url("https://www.transparenttextures.com/patterns/cream-paper.png");
        border: 2px solid #ff99cc;
      }
      .modal-content h2 {
        font-family: "Dancing Script", cursive;
        color: #d63384;
        font-size: 2.5rem;
        margin-top: 0;
        margin-bottom: 15px;
        border-bottom: 1px dashed #ff99cc;
        padding-bottom: 10px;
      }
      .modal-content p {
        font-family: "Segoe UI", sans-serif;
        color: #555;
        font-size: 1.15rem;
        line-height: 1.6;
      }
      .close-btn {
        position: absolute;
        top: 10px;
        right: 15px;
        font-size: 2rem;
        cursor: pointer;
        color: #ff99cc;
        transition: color 0.3s;
        line-height: 1;
      }
      .close-btn:hover {
        color: #d63384;
      }
    </style>
  </head>
  <body>
    <!-- M√†n h√¨nh ch·ªù ban ƒë·∫ßu -->
    <div id="greeting-overlay">
      <h5 id="greet-title"></h5>
      <p id="greet-message"></p>
    </div>

    <!-- L·ªùi ch√∫c ch√≠nh hi·ªán ra sau khi g√¥m t·ª• -->
    <div id="main-message"></div>

    <!-- Container ch·ª©a th∆∞ r∆°i -->
    <div id="letters-container"></div>

    <!-- Modal thi·ªáp -->
    <div id="card-modal" onclick="closeCard(event)">
      <div class="modal-content" onclick="event.stopPropagation()">
        <span class="close-btn" onclick="closeCard()">√ó</span>
        <h2 id="modal-title">Title</h2>
        <p id="modal-body">Content goes here...</p>
      </div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script>
      // D·ªØ li·ªáu l·ªùi ch√∫c cho c√°c l√° th∆∞
      const wishes = [
        {
          title: "G·ª≠i Em",
          content:
            "C·∫£m ∆°n em ƒë√£ ƒë·∫øn v√† l√†m th·∫ø gi·ªõi c·ªßa anh tr·ªü n√™n r·ª±c r·ª°. Happy Valentine!",
        },
        {
          title: "My Love",
          content:
            "M·ªói l√° th∆∞ l√† m·ªôt m·∫£nh gh√©p t√¨nh y√™u anh d√†nh cho em. Y√™u em nhi·ªÅu!",
        },
        {
          title: "Sweetheart",
          content:
            "Mong r·∫±ng n·ª• c∆∞·ªùi c·ªßa em s·∫Ω lu√¥n t·ªèa s√°ng nh∆∞ b·∫ßu tr·ªùi ƒë√™m nay.",
        },
        {
          title: "Forever",
          content:
            "D√π th·ªùi gian c√≥ tr√¥i, t√¨nh c·∫£m anh d√†nh cho em v·∫´n m√£i nguy√™n v·∫πn.",
        },
        {
          title: "B√© Y√™u",
          content:
            "Em l√† ƒëi·ªÅu ng·ªçt ng√†o nh·∫•t m√† anh t·ª´ng c√≥. Ch√∫c em m·ªôt ng√†y th·∫≠t vui!",
        },
        {
          title: "Sunshine",
          content:
            "Em l√† √°nh n·∫Øng ·∫•m √°p trong nh·ªØng ng√†y ƒë√¥ng l·∫°nh gi√° c·ªßa anh.",
        },
      ];

      const icons = ["üíå", "üíñ", "üéÅ", "üåπ", "‚ú®", "üéÄ"];

      // --- LOGIC TH∆Ø R∆†I (FALLING LETTERS) ---
      function spawnFallingLetter() {
        const container = document.getElementById("letters-container");
        const el = document.createElement("div");
        el.classList.add("falling-item");
        el.innerText = icons[Math.floor(Math.random() * icons.length)];

        const startX = Math.random() * window.innerWidth;
        const duration = 6 + Math.random() * 6; // R∆°i trong 6-12 gi√¢y
        const rotationDir = Math.random() > 0.5 ? 1 : -1;

        gsap.set(el, {
          x: startX,
          y: -100,
          rotation: Math.random() * 360,
        });

        el.onclick = function () {
          gsap.killTweensOf(el);
          gsap.to(el, {
            scale: 2,
            opacity: 0,
            duration: 0.5,
            onComplete: () => el.remove(),
          });
          openCard(Math.floor(Math.random() * wishes.length));
        };

        container.appendChild(el);

        gsap.to(el, {
          y: window.innerHeight + 100,
          duration: duration,
          ease: "none",
          onComplete: () => {
            el.remove();
            spawnFallingLetter();
          },
        });

        gsap.to(el, {
          x: startX + (Math.random() - 0.5) * 200,
          rotation: `+=${360 * rotationDir}`,
          duration: duration,
          ease: "sine.inOut",
        });
      }

      function startFallingLetters() {
        for (let i = 0; i < 10; i++) {
          setTimeout(spawnFallingLetter, Math.random() * 5000);
        }
      }

      // --- MODAL LOGIC ---
      function openCard(index) {
        const modal = document.getElementById("card-modal");
        const content = document.querySelector(".modal-content");
        document.getElementById("modal-title").innerText = wishes[index].title;
        document.getElementById("modal-body").innerText = wishes[index].content;
        modal.style.display = "flex";
        gsap.to(modal, { duration: 0.5, opacity: 1 });
        gsap.fromTo(
          content,
          { scale: 0.5, opacity: 0, rotation: -10 },
          {
            duration: 0.6,
            scale: 1,
            opacity: 1,
            rotation: 0,
            ease: "back.out(1.7)",
          },
        );
      }

      function closeCard(event) {
        const modal = document.getElementById("card-modal");
        const content = document.querySelector(".modal-content");
        gsap.to(content, {
          duration: 0.3,
          scale: 0.5,
          opacity: 0,
          ease: "power2.in",
          onComplete: () => {
            gsap.to(modal, {
              duration: 0.2,
              opacity: 0,
              onComplete: () => {
                modal.style.display = "none";
              },
            });
          },
        });
      }

      window.closeCard = closeCard;
      window.startFallingLetters = startFallingLetters;
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // --- THREE.JS SETUP ---
      const CONF = {
        particleCount: 75000,
        particleSize: 0.25,
        heartColor: 0xff0000,
        heartScale: 12,
        orbitRadius: 28,
        sparkleSpeed: 4.0,
        sparkleIntensity: 0.4,
        totalIntroTime: 28.0,
      };
      let animationStarted = false;
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.002);
      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        2000,
      );
      camera.position.set(0, 5, 100);
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;

      // Stars
      const sGeo = new THREE.BufferGeometry();
      const sPos = [];
      for (let i = 0; i < 10000; i++)
        sPos.push(
          (Math.random() - 0.5) * 600,
          (Math.random() - 0.5) * 600,
          (Math.random() - 0.5) * 600,
        );
      sGeo.setAttribute("position", new THREE.Float32BufferAttribute(sPos, 3));

      const starTex = (() => {
        const c = document.createElement("canvas");
        c.width = 28;
        c.height = 28;
        const x = c.getContext("2d");
        const g = x.createRadialGradient(16, 16, 0, 16, 16, 16);
        g.addColorStop(0, "white");
        g.addColorStop(1, "transparent");
        x.fillStyle = g;
        x.fillRect(0, 0, 32, 32);
        return new THREE.CanvasTexture(c);
      })();
      scene.add(
        new THREE.Points(
          sGeo,
          new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.8,
            map: starTex,
            transparent: true,
            opacity: 0.8,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
          }),
        ),
      );

      // Heart
      const hGeo = new THREE.BufferGeometry();
      const curr = [],
        init = [],
        final = [],
        sched = [],
        cols = [],
        baseCols = [],
        offs = [];
      const baseCol = new THREE.Color(CONF.heartColor);
      let i = 0;
      while (i < CONF.particleCount) {
        const x = Math.random() * 3 - 1.5,
          y = Math.random() * 3 - 1.5,
          z = Math.random() * 3 - 1.5;
        if (
          (x * x + 2.25 * z * z + y * y - 1) ** 3 -
            x * x * y * y * y -
            0.1125 * z * z * y * y * y <
          0
        ) {
          final.push(
            x * CONF.heartScale,
            y * CONF.heartScale,
            z * CONF.heartScale,
          );
          const r = 300 + Math.random() * 200,
            th = Math.random() * Math.PI * 2,
            ph = Math.random() * Math.PI;
          init.push(
            r * Math.sin(ph) * Math.cos(th),
            r * Math.sin(ph) * Math.sin(th),
            r * Math.cos(ph),
          );
          curr.push(init[i * 3], init[i * 3 + 1], init[i * 3 + 2]);
          // T·ªëc ƒë·ªô bay: 1.5 - 3s
          sched.push({
            s: Math.random() * (CONF.totalIntroTime - 3),
            d: 4 + Math.random() * 1.5,
          });
          const c = baseCol.clone();
          c.multiplyScalar(1 + y * 0.2 + (Math.random() - 0.5) * 0.1);
          if (c.g > 0.1) c.g = 0;
          cols.push(c.r, c.g, c.b);
          baseCols.push(c.r, c.g, c.b);
          offs.push(Math.random() * Math.PI * 2);
          i++;
        }
      }
      hGeo.setAttribute("position", new THREE.Float32BufferAttribute(curr, 3));
      hGeo.setAttribute("color", new THREE.Float32BufferAttribute(cols, 3));
      const hMesh = new THREE.Points(
        hGeo,
        new THREE.PointsMaterial({
          size: CONF.particleSize,
          map: starTex,
          vertexColors: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          transparent: true,
          opacity: 0.9,
        }),
      );
      scene.add(hMesh);

      // Text (Particles - 3D) - V·∫´n gi·ªØ nh∆∞ng m·∫∑c ƒë·ªãnh ·∫©n, s·∫Ω hi·ªán c√πng nh·ªãp tim
      function createTxt(t) {
        const c = document.createElement("canvas");
        const x = c.getContext("2d");
        c.width = 1000;
        c.height = 200;
        x.font = "bold 100px 'Segoe UI'";
        x.fillStyle = "white";
        x.textAlign = "center";
        x.textBaseline = "middle";
        x.fillText(t, 500, 100);
        const d = x.getImageData(0, 0, 1000, 200);
        const p = [],
          cl = [];
        const co = new THREE.Color(0xff88cc);
        for (let j = 0; j < 200; j += 3)
          for (let k = 0; k < 1000; k += 3)
            if (d.data[(j * 1000 + k) * 4 + 3] > 128) {
              p.push((k - 500) * 0.045, -(j - 100) * 0.045 - 18, 0);
              const nc = co.clone();
              nc.r += (Math.random() - 0.5) * 0.1;
              cl.push(nc.r, nc.g, nc.b);
            }
        const g = new THREE.BufferGeometry();
        g.setAttribute("position", new THREE.Float32BufferAttribute(p, 3));
        g.setAttribute("color", new THREE.Float32BufferAttribute(cl, 3));
        return { g, c: cl };
      }
      const tDat = createTxt("Happy Valentine's Day");
      const tMat = new THREE.PointsMaterial({
        size: 0.35,
        map: starTex,
        vertexColors: true,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      const tMesh = new THREE.Points(tDat.g, tMat);
      scene.add(tMesh);

      // Orbit
      const rGrp = new THREE.Group();
      scene.add(rGrp);
      const oMat = new THREE.MeshBasicMaterial({
        color: 0xff99cc,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
      });
      rGrp.add(
        new THREE.Mesh(
          new THREE.TorusGeometry(CONF.orbitRadius, 0.05, 16, 100),
          oMat,
        ).rotateX(Math.PI / 2),
      );

      // --- K·ªäCH B·∫¢N CH√çNH (GSAP TIMELINE) ---
      gsap
        .timeline()
        // 1. M√†n h√¨nh ch·ªù: Hi·ªán ch·ªØ "G·ª≠i ng∆∞·ªùi t·ªõ th∆∞∆°ng..."
        .set("#greeting-overlay", { opacity: 1 })
        .to("#greet-title", {
          duration: 2.5,
          text: "G·ª≠i ƒë·∫øn ng∆∞·ªùi anh th∆∞∆°ng",
          ease: "none",
          opacity: 1,
        })
        .to(
          "#greet-message",
          {
            duration: 6,
            text: "ƒê√¢y l√† m√≥n qu√† nh·ªè anh d√†nh t·∫∑ng em trong ng√†y Valentine. Hy v·ªçng n√≥ s·∫Ω mang l·∫°i n·ª• c∆∞·ªùi v√† ni·ªÅm vui cho em!",
            ease: "none",
            opacity: 1,
          },
          "+=0.5",
        )
        // 2. ·∫®n m√†n h√¨nh ch·ªù -> B·∫Øt ƒë·∫ßu 3D
        .to("#greeting-overlay", {
          duration: 2,
          opacity: 0,
          delay: 1,
          onComplete: () => {
            document.getElementById("greeting-overlay").style.display = "none";
            animationStarted = true;
            startTime = clock.getElapsedTime();

            // --- LOGIC M·ªöI: CH·ªú G√îM T·ª§ XONG M·ªöI HI·ªÜN CH·ªÆ ---
            // Th·ªùi gian g√¥m t·ª• l√† kho·∫£ng 10 gi√¢y (8s intro + 2s buffer)
            setTimeout(
              () => {
                // 3. Hi·ªán l·ªùi ch√∫c ch√≠nh (Typewriter)
                const msgEl = document.getElementById("main-message");
                gsap.to(msgEl, { opacity: 1, duration: 1 }); // Fade in container
                gsap.to(msgEl, {
                  // ƒêo·∫°n vƒÉn l·ªùi ch√∫c l√£ng m·∫°n
                  text: "G·ª≠i em, ng∆∞·ªùi con g√°i anh y√™u th∆∞∆°ng nh·∫•t. C·∫£m ∆°n em ƒë√£ ƒë·∫øn v√† mang l·∫°i √°nh s√°ng cho cu·ªôc ƒë·ªùi anh. M·ªói kho·∫£nh kh·∫Øc b√™n em ƒë·ªÅu l√† m·ªôt m√≥n qu√† v√¥ gi√°. Ch√∫c em m·ªôt ng√†y Valentine th·∫≠t h·∫°nh ph√∫c v√† tr√†n ng·∫≠p y√™u th∆∞∆°ng! ‚ù§Ô∏è",
                  duration: 12, // TƒÉng th·ªùi gian g√µ v√¨ ƒëo·∫°n vƒÉn d√†i
                  ease: "none",
                  onComplete: () => {
                    // 4. ƒê·ª£i ng∆∞·ªùi d√πng ƒë·ªçc xong (5 gi√¢y) -> ·∫®n ƒëi
                    gsap.to(msgEl, {
                      opacity: 0,
                      delay: 6,
                      duration: 1.5,
                      onComplete: () => {
                        // 5. B·∫Øt ƒë·∫ßu m∆∞a th∆∞ t√¨nh
                        window.startFallingLetters();
                      },
                    });
                  },
                });
              },
              (CONF.totalIntroTime + 1.5) * 1000,
            ); // Ch·ªù kho·∫£ng 9.5s ƒë·ªÉ tim h√¨nh th√†nh r√µ
          },
        });

      // Animation Loop
      const clock = new THREE.Clock();
      let startTime = null;
      let cOpc = 0;
      function easeOutCubic(x) {
        return 1 - Math.pow(1 - x, 3);
      }

      function animate() {
        requestAnimationFrame(animate);
        if (!animationStarted) {
          renderer.render(scene, camera);
          return;
        }
        const elp = clock.getElapsedTime() - startTime;

        // Heart Construction Phase
        if (elp < CONF.totalIntroTime + 2) {
          const pos = hMesh.geometry.attributes.position.array;
          for (let i = 0; i < CONF.particleCount; i++) {
            const s = sched[i];
            if (elp >= s.s) {
              const p = elp < s.s + s.d ? easeOutCubic((elp - s.s) / s.d) : 1;
              const i3 = i * 3;
              pos[i3] = init[i3] + (final[i3] - init[i3]) * p;
              pos[i3 + 1] = init[i3 + 1] + (final[i3 + 1] - init[i3 + 1]) * p;
              pos[i3 + 2] = init[i3 + 2] + (final[i3 + 2] - init[i3 + 2]) * p;
            }
          }
          hMesh.geometry.attributes.position.needsUpdate = true;
        }

        // Heart Beat & Reveal Phase
        if (elp > CONF.totalIntroTime * 0.8) {
          hMesh.scale.setScalar(
            1 + Math.pow(Math.sin(clock.getElapsedTime() * 0.5), 2) * 0.6,
          );
          if (cOpc < 1) {
            cOpc += 0.003;
            if (cOpc > 1) cOpc = 1;
            oMat.opacity = cOpc * 0.6;
            tMat.opacity = cOpc; // Ch·ªØ 3D c≈©ng hi·ªán d·∫ßn l√™n l√†m n·ªÅn
          }
        }

        // Sparkle
        const cols = hMesh.geometry.attributes.color.array;
        const now = clock.getElapsedTime();
        for (let i = 0; i < CONF.particleCount; i++) {
          const f =
            1 +
            Math.sin(now * CONF.sparkleSpeed + offs[i]) * CONF.sparkleIntensity;
          const i3 = i * 3;
          cols[i3] = Math.max(0, baseCols[i3] * f);
          cols[i3 + 1] = Math.max(0, baseCols[i3 + 1] * f);
          cols[i3 + 2] = Math.max(0, baseCols[i3 + 2] * f);
        }
        hMesh.geometry.attributes.color.needsUpdate = true;

        // Text Sparkle (3D)
        if (tMat.opacity > 0) {
          const tc = tMesh.geometry.attributes.color.array;
          const tbc = tDat.c;
          for (let i = 0; i < tbc.length / 3; i++) {
            const f = 1 + Math.sin(now * 5 + i) * 0.5;
            const i3 = i * 3;
            tc[i3] = Math.max(0, tbc[i3] * f);
            tc[i3 + 1] = Math.max(0, tbc[i3 + 1] * f);
            tc[i3 + 2] = Math.max(0, tbc[i3 + 2] * f);
          }
          tMesh.geometry.attributes.color.needsUpdate = true;
        }

        rGrp.rotation.y = Math.sin(now * 0.1) * 0.1;
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
