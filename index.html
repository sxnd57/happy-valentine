<!doctype html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Valentine Cinematic</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      canvas {
        display: block;
      }

      /* --- MÀN HÌNH CHÚC MỪNG (GREETING) --- */
      #greeting-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 200;
        transition: opacity 2.5s ease-in-out;
      }

      /* CSS cho chữ ẩn lúc đầu */
      #greeting-overlay h1,
      #greeting-overlay p {
        opacity: 0; /* Ẩn */
        transform: translateY(20px); /* Dịch xuống dưới chút */
        transition:
          opacity 2s ease-out,
          transform 2s ease-out; /* Hiệu ứng hiện từ từ */
        text-align: center;
      }

      /* Class này sẽ được JS thêm vào để hiện chữ */
      #greeting-overlay .visible {
        opacity: 1 !important;
        transform: translateY(0) !important;
      }

      #greeting-overlay h5 {
        color: #ff0055;
        font-size: 1.5rem;
        margin: 0;
        text-shadow: 0 0 30px rgba(255, 0, 85, 0.8);
        /* Animation nhịp đập nhẹ cho tiêu đề */
        animation: pulseText 3s infinite;
        text-align: center;
      }

      #greeting-overlay p {
        color: #fff;
        font-size: 1.5rem;
        margin-top: 30px;
        opacity: 0;
        font-weight: 300;
        letter-spacing: 2px;
        max-width: 80%;
        line-height: 1.6;
      }

      @keyframes pulseText {
        0% {
          text-shadow: 0 0 30px rgba(255, 0, 85, 0.8);
        }
        50% {
          text-shadow: 0 0 60px rgba(255, 0, 85, 1);
        }
        100% {
          text-shadow: 0 0 30px rgba(255, 0, 85, 0.8);
        }
      }
    </style>
  </head>
  <body>
    <!-- MÀN HÌNH CHÚC MỪNG -->
    <div id="greeting-overlay">
      <h5 id="greet-title">Happy Valentine's Day</h5>
      <p id="greet-message">Gửi trọn yêu thương đến người anh yêu ❤️</p>
    </div>

    <!-- LOADING TEXT -->

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // ========================================================================
      // --- KHU VỰC ẢNH ---
      // ========================================================================
      const MY_PHOTOS = [
        "/photo/img1.jpg",
        "/photo/img2.jpg",
        "/photo/img4.jpg",
        "/photo/img5.jpg",
        "/photo/img6.jpg",
        "/photo/img8.jpg",
        "/photo/img9.jpg",
        "/photo/img10.jpg",
        "/photo/img11.jpg",
        "/photo/img12.jpg",
        "/photo/img13.jpg",
        "/photo/img14.jpg",
        "/photo/img15.jpg",
        "/photo/img16.jpg",
        "/photo/img17.jpg",
        "/photo/img18.jpg",
      ];
      // ========================================================================

      const CONF = {
        particleCount: 75000,
        particleSize: 0.25,
        heartColor: 0xff0000,
        heartScale: 12,
        orbitRadius: 28,
        sparkleSpeed: 4.0,
        sparkleIntensity: 0.4,
        totalIntroTime: 18.0,
      };

      let introFinished = false;
      let currentOrbitOpacity = 0.0;
      let animationStarted = false;

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.002);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        2000,
      );
      camera.position.set(0, 5, 100);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;

      // --- STARS ---
      function getStarTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext("2d");
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, "rgba(255, 255, 255, 1)");
        grad.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 32, 32);
        return new THREE.CanvasTexture(canvas);
      }
      const starGeo = new THREE.BufferGeometry();
      const starPos = [];
      const starCount = 10000;
      for (let i = 0; i < starCount; i++)
        starPos.push(
          (Math.random() - 0.5) * 600,
          (Math.random() - 0.5) * 600,
          (Math.random() - 0.5) * 600,
        );
      starGeo.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(starPos, 3),
      );
      const starMat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.8,
        map: getStarTexture(),
        transparent: true,
        opacity: 0.8,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });
      scene.add(new THREE.Points(starGeo, starMat));

      // --- HEART ---
      function getHeartTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext("2d");
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, "rgba(255, 255, 255, 1)");
        grad.addColorStop(0.2, "rgba(255, 255, 255, 0.8)");
        grad.addColorStop(0.5, "rgba(255, 255, 255, 0.2)");
        grad.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 32, 32);
        return new THREE.CanvasTexture(canvas);
      }

      const geometry = new THREE.BufferGeometry();
      const currentPositions = [];
      const initialPositions = [];
      const finalPositions = [];
      const particleSchedules = [];
      const colors = [];
      const baseColors = [];
      const sparkleOffsets = [];
      const baseColorObj = new THREE.Color(CONF.heartColor);

      let i = 0;
      while (i < CONF.particleCount) {
        const x = Math.random() * 3 - 1.5;
        const y = Math.random() * 3 - 1.5;
        const z = Math.random() * 3 - 1.5;
        const a = x * x + (9 / 4) * z * z + y * y - 1;
        const result =
          a * a * a - x * x * y * y * y - (9 / 80) * z * z * y * y * y;

        if (result < 0) {
          finalPositions.push(
            x * CONF.heartScale,
            y * CONF.heartScale,
            z * CONF.heartScale,
          );
          const r = 300 + Math.random() * 200;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const startX = r * Math.sin(phi) * Math.cos(theta);
          const startY = r * Math.sin(phi) * Math.sin(theta);
          const startZ = r * Math.cos(phi);
          initialPositions.push(startX, startY, startZ);
          currentPositions.push(startX, startY, startZ);

          const myStartTime = Math.random() * (CONF.totalIntroTime - 3.0);
          const myDuration = 3.0 + Math.random() * 2.0;

          particleSchedules.push({ start: myStartTime, duration: myDuration });

          const c = baseColorObj.clone();
          let brightness = 1.0 + y * 0.2 + (Math.random() - 0.5) * 0.1;
          c.multiplyScalar(brightness);
          if (c.g > 0.1) c.g = 0.0;
          colors.push(c.r, c.g, c.b);
          baseColors.push(c.r, c.g, c.b);
          sparkleOffsets.push(Math.random() * Math.PI * 2);
          i++;
        }
      }
      geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(currentPositions, 3),
      );
      geometry.setAttribute(
        "color",
        new THREE.Float32BufferAttribute(colors, 3),
      );
      const material = new THREE.PointsMaterial({
        size: CONF.particleSize,
        map: getHeartTexture(),
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.9,
      });
      const heartMesh = new THREE.Points(geometry, material);
      scene.add(heartMesh);

      // ================================================================
      // --- TEXT "HAPPY VALENTINE" ---
      // ================================================================
      function createTextParticles(text) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = 1000;
        canvas.height = 200;

        ctx.font = "bold 100px 'Segoe UI', Arial, sans-serif";
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);

        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const positions = [];
        const colors = [];
        const textBaseColors = [];
        const textSparkleOffsets = [];
        const colorObj = new THREE.Color(0xff88cc);

        for (let y = 0; y < canvas.height; y += 3) {
          for (let x = 0; x < canvas.width; x += 3) {
            const index = (y * canvas.width + x) * 4;
            const alpha = imgData.data[index + 3];

            if (alpha > 128) {
              const scale = 0.045;
              const pX = (x - canvas.width / 2) * scale;
              const pY = -(y - canvas.height / 2) * scale - 18;
              const pZ = 0;

              positions.push(pX, pY, pZ);

              const c = colorObj.clone();
              c.r += (Math.random() - 0.5) * 0.1;
              c.b += (Math.random() - 0.5) * 0.1;

              colors.push(c.r, c.g, c.b);
              textBaseColors.push(c.r, c.g, c.b);
              textSparkleOffsets.push(Math.random() * Math.PI * 2);
            }
          }
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3),
        );
        geometry.setAttribute(
          "color",
          new THREE.Float32BufferAttribute(colors, 3),
        );

        return { geometry, textBaseColors, textSparkleOffsets };
      }

      const textData = createTextParticles("Happy Valentine's Day");
      const textMat = new THREE.PointsMaterial({
        size: 0.35,
        map: getHeartTexture(),
        vertexColors: true,
        transparent: true,
        opacity: 0.0,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      const textMesh = new THREE.Points(textData.geometry, textMat);
      scene.add(textMesh);

      // --- 3 ORBITS SYSTEM ---
      const ringGroup = new THREE.Group();
      scene.add(ringGroup);

      function getPhotoTexture(index) {
        const loader = new THREE.TextureLoader();
        let url =
          MY_PHOTOS.length > 0
            ? MY_PHOTOS[index % MY_PHOTOS.length]
            : `https://picsum.photos/200/150?random=${index}`;
        return loader.load(url);
      }
      function createPhoto(idx, offset) {
        const mesh = new THREE.Mesh(
          new THREE.PlaneGeometry(4, 3),
          new THREE.MeshBasicMaterial({
            side: THREE.DoubleSide,
            map: getPhotoTexture(idx),
            color: 0xffffff,
            transparent: true,
            opacity: 0,
          }),
        );
        mesh.add(
          new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.PlaneGeometry(4, 3)),
            new THREE.LineBasicMaterial({
              color: 0xff66aa,
              transparent: true,
              opacity: 0,
              blending: THREE.AdditiveBlending,
            }),
          ),
        );
        return {
          mesh,
          angle: (idx / 6) * Math.PI * 2 + offset,
          radius: CONF.orbitRadius,
        };
      }
      const photos = [];
      const orbit1 = new THREE.Group();
      const orbit2 = new THREE.Group();
      const orbit3 = new THREE.Group();

      orbit1.rotation.z = Math.PI / 4;
      orbit2.rotation.z = Math.PI / 4;
      orbit2.rotation.y = (2 * Math.PI) / 3;
      orbit3.rotation.z = Math.PI / 4;
      orbit3.rotation.y = (4 * Math.PI) / 3;

      ringGroup.add(orbit1);
      ringGroup.add(orbit2);
      ringGroup.add(orbit3);

      const orbitPathMat = new THREE.MeshBasicMaterial({
        color: 0xff99cc,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
      });
      const orbitPathGeo = new THREE.TorusGeometry(
        CONF.orbitRadius,
        0.05,
        16,
        100,
      );
      orbit1.add(
        new THREE.Mesh(orbitPathGeo, orbitPathMat).rotateX(Math.PI / 2),
      );
      orbit2.add(
        new THREE.Mesh(orbitPathGeo, orbitPathMat).rotateX(Math.PI / 2),
      );
      orbit3.add(
        new THREE.Mesh(orbitPathGeo, orbitPathMat).rotateX(Math.PI / 2),
      );

      for (let j = 0; j < 6; j++) {
        let p1 = createPhoto(j, 0);
        orbit1.add(p1.mesh);
        photos.push(p1);
        let p2 = createPhoto(j + 6, Math.PI / 6);
        orbit2.add(p2.mesh);
        photos.push(p2);
        let p3 = createPhoto(j + 12, Math.PI / 3);
        orbit3.add(p3.mesh);
        photos.push(p3);
      }

      // --- SHOOTING STARS ---
      function getShootingStarTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 32;
        const ctx = canvas.getContext("2d");
        const grad = ctx.createLinearGradient(0, 0, 128, 0);
        grad.addColorStop(0, "rgba(255, 255, 255, 0)");
        grad.addColorStop(0.5, "rgba(255, 255, 255, 1)");
        grad.addColorStop(1, "rgba(255, 255, 255, 0)");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 128, 32);
        return new THREE.CanvasTexture(canvas);
      }
      const shootingStars = [];
      const shootingStarGeo = new THREE.PlaneGeometry(12, 0.5);
      const shootingStarMat = new THREE.MeshBasicMaterial({
        map: getShootingStarTexture(),
        side: THREE.DoubleSide,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      for (let i = 0; i < 6; i++) {
        const mesh = new THREE.Mesh(shootingStarGeo, shootingStarMat);
        mesh.visible = false;
        scene.add(mesh);
        shootingStars.push({ mesh, active: false, speed: 0 });
      }
      function spawnShootingStar() {
        const star = shootingStars.find((s) => !s.active);
        if (!star) return;
        star.active = true;
        star.mesh.visible = true;
        star.mesh.position.set(
          (Math.random() - 0.5) * 200,
          80 + Math.random() * 50,
          (Math.random() - 0.5) * 100,
        );
        star.mesh.rotation.z = -Math.PI / 4 + (Math.random() - 0.5) * 0.5;
        star.speed = 1.5 + Math.random();
      }

      // --- LOGIC CHUYỂN CẢNH (GREETING -> MAIN) ---
      const overlay = document.getElementById("greeting-overlay");
      const title = document.getElementById("greet-title");
      const message = document.getElementById("greet-message");

      // 1. Hiện dòng 1: Happy Valentine's Day (Sau 0.5s)
      setTimeout(() => {
        title.classList.add("visible");
      }, 500);

      // 2. Hiện dòng 2: Lời chúc (Sau 2.5s)
      setTimeout(() => {
        message.classList.add("visible");
      }, 2500);

      // 3. Ẩn Overlay (Sau 6.5s)
      setTimeout(() => {
        overlay.style.opacity = "0";

        // 4. Bắt đầu gôm tụ trái tim (Sau khi overlay mờ hẳn)
        setTimeout(() => {
          overlay.style.display = "none";
          animationStarted = true;
          document.getElementById("loading").style.opacity = 1;
        }, 2500); // Chờ 2.5s cho overlay mờ dần
      }, 6500); // Chờ 6.5s để người dùng đọc chữ

      // --- ANIMATION LOOP ---
      const clock = new THREE.Clock();
      const loadingEl = document.getElementById("loading");
      let startTime = null;

      function easeOutCubic(x) {
        return 1 - Math.pow(1 - x, 3);
      }

      function animate() {
        requestAnimationFrame(animate);

        if (!animationStarted) {
          // Chỉ chạy hiệu ứng sao bay và sao băng khi đang hiện chữ
          if (Math.random() < 0.04) spawnShootingStar();
          shootingStars.forEach((star) => {
            if (star.active) {
              star.mesh.translateX(star.speed);
              if (star.mesh.position.x > 200 || star.mesh.position.y < -100) {
                star.active = false;
                star.mesh.visible = false;
              }
            }
          });
          renderer.render(scene, camera);
          return;
        }

        // BẮT ĐẦU GÔM TỤ
        if (startTime === null) startTime = clock.getElapsedTime();
        const now = clock.getElapsedTime();
        const elapsed = now - startTime;

        // 1. CONSTRUCTION PHASE
        if (elapsed < CONF.totalIntroTime + 2.0) {
          const posAttr = heartMesh.geometry.attributes.position;
          const posArray = posAttr.array;
          for (let i = 0; i < CONF.particleCount; i++) {
            const schedule = particleSchedules[i];
            if (elapsed >= schedule.start) {
              if (elapsed < schedule.start + schedule.duration) {
                let localProgress =
                  (elapsed - schedule.start) / schedule.duration;
                localProgress = easeOutCubic(localProgress);
                const i3 = i * 3;
                posArray[i3] =
                  initialPositions[i3] +
                  (finalPositions[i3] - initialPositions[i3]) * localProgress;
                posArray[i3 + 1] =
                  initialPositions[i3 + 1] +
                  (finalPositions[i3 + 1] - initialPositions[i3 + 1]) *
                    localProgress;
                posArray[i3 + 2] =
                  initialPositions[i3 + 2] +
                  (finalPositions[i3 + 2] - initialPositions[i3 + 2]) *
                    localProgress;
              } else {
                const i3 = i * 3;
                posArray[i3] = finalPositions[i3];
                posArray[i3 + 1] = finalPositions[i3 + 1];
                posArray[i3 + 2] = finalPositions[i3 + 2];
              }
            }
          }
          posAttr.needsUpdate = true;
        } else {
          if (!introFinished) {
            introFinished = true;
            loadingEl.style.opacity = 0;
          }
        }

        // 2. ORBIT & TEXT REVEAL
        if (elapsed > CONF.totalIntroTime * 0.8) {
          const beat = Math.pow(Math.sin(now * 0.5), 2) * 0.3;
          heartMesh.scale.setScalar(1 + beat);

          if (currentOrbitOpacity < 1.0) {
            currentOrbitOpacity += 0.003;
            if (currentOrbitOpacity > 1.0) currentOrbitOpacity = 1.0;

            orbitPathMat.opacity = currentOrbitOpacity * 0.6;

            textMat.opacity = currentOrbitOpacity;

            photos.forEach((p) => {
              p.mesh.material.opacity = currentOrbitOpacity;
              if (p.mesh.children[0])
                p.mesh.children[0].material.opacity = currentOrbitOpacity * 0.8;
            });
          }
        }

        // HEART SPARKLE
        const heartColorAttr = heartMesh.geometry.attributes.color;
        for (let i = 0; i < CONF.particleCount; i++) {
          const i3 = i * 3;
          const factor =
            1.0 +
            Math.sin(now * CONF.sparkleSpeed + sparkleOffsets[i]) *
              CONF.sparkleIntensity;
          heartColorAttr.array[i3] = Math.max(0, baseColors[i3] * factor);
          heartColorAttr.array[i3 + 1] = Math.max(
            0,
            baseColors[i3 + 1] * factor,
          );
          heartColorAttr.array[i3 + 2] = Math.max(
            0,
            baseColors[i3 + 2] * factor,
          );
        }
        heartColorAttr.needsUpdate = true;

        // TEXT SPARKLE
        if (textMat.opacity > 0) {
          const textColorAttr = textMesh.geometry.attributes.color;
          const count = textData.textBaseColors.length / 3;
          for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            const factor =
              1.0 + Math.sin(now * 5.0 + textData.textSparkleOffsets[i]) * 0.5;
            textColorAttr.array[i3] = Math.max(
              0,
              textData.textBaseColors[i3] * factor,
            );
            textColorAttr.array[i3 + 1] = Math.max(
              0,
              textData.textBaseColors[i3 + 1] * factor,
            );
            textColorAttr.array[i3 + 2] = Math.max(
              0,
              textData.textBaseColors[i3 + 2] * factor,
            );
          }
          textColorAttr.needsUpdate = true;
        }

        if (Math.random() < 0.04) spawnShootingStar();
        shootingStars.forEach((star) => {
          if (star.active) {
            star.mesh.translateX(star.speed);
            if (star.mesh.position.x > 200 || star.mesh.position.y < -100) {
              star.active = false;
              star.mesh.visible = false;
            }
          }
        });

        photos.forEach((p) => {
          p.angle += 0.003;
          p.mesh.position.x = Math.cos(p.angle) * p.radius;
          p.mesh.position.y = Math.sin(p.angle) * p.radius;
          p.mesh.lookAt(camera.position);
        });

        ringGroup.rotation.y = Math.sin(now * 0.1) * 0.1;

        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
